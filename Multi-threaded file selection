package 多线程;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * @Author wuyifan
 * @Date 2024/4/19 11:03
 * @Version 1.0
 */
public class ThreadChoiceWav {

        static HashSet<String> foundTags = new HashSet<String>();
        static List<String> results = new ArrayList<>();

        public static void main(String[] args) {
            String inputFilePath = "D:\\JAVA\\javacode\\JavaPoints\\多线程\\train.txt";
            String outputFilePath = "D:\\JAVA\\javacode\\JavaPoints\\多线程\\enroll.txt";

            // Read lines from input file
            List<String> lines = new ArrayList<>();
            try {
                lines = Files.readAllLines(Paths.get(inputFilePath));
            } catch (Exception e) {
                e.printStackTrace();
            }

//          创建了一个固定大小的线程池，大小为10。这意味着同时最多可以有10个线程在运行。
            ExecutorService executor = Executors.newFixedThreadPool(10);
//            每一个Future对象代表着一个已提交至线程池的任务的结果
            List<Future<String>> futures = new ArrayList<>();

            for (String line : lines){
                futures.add(executor.submit(() -> checkDurationAndTag(line)));
            }

            executor.shutdown();

            try {
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
            }

//          从每个future中获取结果并添加到结果列表中
            for (Future<String> future : futures) {
                try {
                    String result = future.get(); // 获取任务执行结果
                    if (result != null) {
                        results.add(result); // 添加有效结果到结果列表
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Write results to output file
            try {
                Files.write(Paths.get(outputFilePath), results);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public static String checkDurationAndTag(String line){
            String[] columns = line.trim().split("  ");
            if (columns.length < 2) return null;
            String path = columns[0];
            String tag = columns[1];

            synchronized (foundTags) {  // In case of check and update simultaneously in a multithread environment.
                if (foundTags.contains(tag)) return null;
            }

            try {
                File file = new File(path);
                AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(file);
                AudioFormat format = audioInputStream.getFormat();
                long frames = audioInputStream.getFrameLength();
                double durationInSeconds = (frames+0.0) / format.getFrameRate();

                if (durationInSeconds >= 0.1) {
                    synchronized (foundTags) {
                        if (!foundTags.contains(tag)) {
                            foundTags.add(tag);
                            return path + "\t" + tag;
                        }
                    }
                }
            } catch (Exception e) {
                System.out.println("Error processing file " + path + ": " + e.getMessage());
            }
            return null;
        }
}
